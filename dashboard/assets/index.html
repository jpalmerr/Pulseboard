<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 1.5rem;
        }

        header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f8fafc;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            transition: background 0.3s;
        }

        .connection-dot.connected {
            background: #22c55e;
        }

        .summary {
            margin-left: auto;
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
        }

        .summary-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.625rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            user-select: none;
            border: 2px solid transparent;
        }

        .summary-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .summary-item:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        .summary-item:focus-visible {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        .summary-item[aria-pressed="true"] {
            background: rgba(255, 255, 255, 0.15);
            border-color: currentColor;
        }

        .summary-item[data-status="up"][aria-pressed="true"] {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
        }

        .summary-item[data-status="degraded"][aria-pressed="true"] {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
        }

        .summary-item[data-status="down"][aria-pressed="true"] {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .clear-indicator {
            display: none;
            margin-left: 0.25rem;
            opacity: 0.7;
            font-size: 0.75rem;
        }

        .summary-item[aria-pressed="true"] .clear-indicator {
            display: inline;
        }

        .summary-item:hover .clear-indicator {
            opacity: 1;
        }

        .summary-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .summary-dot.up { background: #22c55e; }
        .summary-dot.degraded { background: #f59e0b; }
        .summary-dot.down { background: #ef4444; }

        .last-updated {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
            padding: 0.375rem 0.625rem;
            border-radius: 0.375rem;
            transition: background 0.3s, color 0.3s;
        }

        .last-updated.stale {
            background: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }

        .last-updated-text {
            white-space: nowrap;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }

        .card {
            background: #1e293b;
            border-radius: 0.5rem;
            padding: 1rem;
            border-left: 4px solid #6b7280;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            cursor: pointer;
        }

        .card.expanded {
            background: #273549;
        }

        .card.down.expanded {
            background: linear-gradient(135deg, #273549 0%, #3d2a3a 100%);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .card.up { border-left-color: #22c55e; }
        .card.degraded {
            border-left-color: #f59e0b;
            background: #1e293b;
            border-left-width: 5px;
        }
        .card.down {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, #1e293b 0%, #2d1f2f 100%);
            border-left-width: 6px;
            box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.2);
        }

        .card.pulse {
            animation: pulse 0.5s ease-out;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            100% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
        }

        .card-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .card-name {
            font-weight: 600;
            font-size: 1rem;
            color: #f8fafc;
            word-break: break-word;
        }

        .status-badge {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            white-space: nowrap;
        }

        .status-badge.up {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .status-badge.degraded {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .status-badge.down {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .stale-badge {
            display: none;
            font-size: 0.625rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            margin-left: 0.5rem;
            cursor: help;
        }

        .card.expanded .stale-badge {
            display: inline-block;
        }

        .card-url {
            font-size: 0.75rem;
            color: #64748b;
            word-break: break-all;
            margin-bottom: 0.75rem;
            display: none;
        }

        .card.expanded .card-url {
            display: block;
        }

        .card-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: #64748b;
        }

        .card-error {
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #fca5a5;
            word-break: break-word;
        }

        .card-labels {
            display: none;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: 0.75rem;
        }

        .card.expanded .card-labels {
            display: flex;
        }

        .label {
            font-size: 0.625rem;
            background: #334155;
            color: #94a3b8;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
        }

        .card.filtered-out {
            display: none;
        }

        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 3rem;
            color: #64748b;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state-message {
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .empty-state-hint {
            font-size: 0.875rem;
            opacity: 0.75;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #64748b;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #334155;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header>
        <h1>{{.Title}}</h1>
        <div class="connection-status">
            <div class="connection-dot" id="connectionDot"></div>
            <span id="connectionText">Connecting...</span>
        </div>
        <div class="last-updated" id="lastUpdated">
            <span class="last-updated-text">Last updated: --</span>
        </div>
        <div class="summary" id="summary" role="group" aria-label="Filter by status">
            <div class="summary-item"
                 data-status="up"
                 role="button"
                 tabindex="0"
                 aria-pressed="false"
                 aria-label="Filter to show only up endpoints">
                <div class="summary-dot up"></div>
                <span id="upCount">0</span> up<span class="clear-indicator" aria-hidden="true">&times;</span>
            </div>
            <div class="summary-item"
                 data-status="degraded"
                 role="button"
                 tabindex="0"
                 aria-pressed="false"
                 aria-label="Filter to show only degraded endpoints">
                <div class="summary-dot degraded"></div>
                <span id="degradedCount">0</span> degraded<span class="clear-indicator" aria-hidden="true">&times;</span>
            </div>
            <div class="summary-item"
                 data-status="down"
                 role="button"
                 tabindex="0"
                 aria-pressed="false"
                 aria-label="Filter to show only down endpoints">
                <div class="summary-dot down"></div>
                <span id="downCount">0</span> down<span class="clear-indicator" aria-hidden="true">&times;</span>
            </div>
        </div>
    </header>

    <main id="grid">
        <div class="loading">
            <div class="loading-spinner"></div>
            <p>Waiting for first poll...</p>
        </div>
    </main>

    <script>
        const grid = document.getElementById('grid');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const upCount = document.getElementById('upCount');
        const degradedCount = document.getElementById('degradedCount');
        const downCount = document.getElementById('downCount');

        // store current statuses and DOM element references
        // note: endpoints are static (defined at SDK startup), so these maps only grow.
        // if dynamic endpoint removal is added, implement cleanup to prevent memory leaks.
        const statuses = new Map();
        const cardElements = new Map();
        let eventSource = null;
        let reconnectAttempts = 0;
        let isShowingLoadingState = true;

        // filter state: null means show all, otherwise 'up' | 'degraded' | 'down'
        let activeFilter = null;

        // track currently expanded card (one at a time on hover)
        let expandedCard = null;

        // track when we last received any status update from the server
        let lastUpdateTime = null;

        // staleness threshold in milliseconds (2 minutes)
        const STALE_THRESHOLD_MS = 2 * 60 * 1000;

        // expand a card (collapse any previously expanded)
        function expandCard(card) {
            if (expandedCard && expandedCard !== card) {
                expandedCard.classList.remove('expanded');
            }
            card.classList.add('expanded');
            expandedCard = card;
        }

        // collapse the currently expanded card
        function collapseCard() {
            if (expandedCard) {
                expandedCard.classList.remove('expanded');
                expandedCard = null;
            }
        }

        // set up hover listeners on a card
        function initCardHoverListeners(card) {
            card.addEventListener('mouseenter', () => expandCard(card));
            card.addEventListener('mouseleave', () => collapseCard());
        }

        // format relative time
        function formatRelativeTime(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffSec = Math.floor(diffMs / 1000);

            if (diffSec < 5) return 'just now';
            if (diffSec < 60) return `${diffSec}s ago`;
            if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
            return `${Math.floor(diffSec / 3600)}h ago`;
        }

        // check if a timestamp is stale (older than threshold)
        function isStale(dateStr) {
            if (!dateStr) return false;
            const checked = new Date(dateStr);
            if (isNaN(checked)) return false;
            return (Date.now() - checked) > STALE_THRESHOLD_MS;
        }

        // create a stale badge element
        function createStaleBadge() {
            const badge = document.createElement('span');
            badge.className = 'stale-badge';
            badge.textContent = 'Stale';
            badge.setAttribute('title', 'This endpoint has not been checked in over 2 minutes');
            badge.setAttribute('aria-label', 'Data is stale - not updated in over 2 minutes');
            return badge;
        }

        // update stale badge on a card (add or remove as needed)
        function updateStaleBadge(card, status) {
            const header = card.querySelector('.card-header');
            if (!header) return;

            let badge = card.querySelector('.stale-badge');
            const cardIsStale = isStale(status.checked_at);

            if (cardIsStale && !badge) {
                header.appendChild(createStaleBadge());
            } else if (!cardIsStale && badge) {
                badge.remove();
            }
        }

        // create a card DOM element (not HTML string)
        function createCardElement(status) {
            const card = document.createElement('div');
            card.className = `card ${status.status}`;
            card.dataset.name = status.name;

            // header with name and status badge
            const header = document.createElement('div');
            header.className = 'card-header';

            const nameDiv = document.createElement('div');
            nameDiv.className = 'card-name';
            nameDiv.textContent = status.name;

            const badge = document.createElement('div');
            badge.className = `status-badge ${status.status}`;
            badge.textContent = status.status;

            header.appendChild(nameDiv);
            header.appendChild(badge);

            // add stale badge if data is already old
            if (isStale(status.checked_at)) {
                header.appendChild(createStaleBadge());
            }

            // url
            const url = document.createElement('div');
            url.className = 'card-url';
            url.textContent = status.url;

            // meta (latency and time)
            const meta = document.createElement('div');
            meta.className = 'card-meta';

            const latency = document.createElement('span');
            latency.className = 'card-latency';
            latency.textContent = `${status.response_time_ms ?? 0}ms`;

            const time = document.createElement('span');
            time.className = 'card-time';
            time.textContent = formatRelativeTime(status.checked_at);

            meta.appendChild(latency);
            meta.appendChild(time);

            card.appendChild(header);
            card.appendChild(url);
            card.appendChild(meta);

            // error (if present)
            if (status.error) {
                const error = document.createElement('div');
                error.className = 'card-error';
                error.textContent = status.error;
                card.appendChild(error);
            }

            // labels (if present)
            const labels = status.labels || {};
            const labelEntries = Object.entries(labels);
            if (labelEntries.length > 0) {
                const labelsDiv = document.createElement('div');
                labelsDiv.className = 'card-labels';
                labelEntries.forEach(([k, v]) => {
                    const label = document.createElement('span');
                    label.className = 'label';
                    label.textContent = `${k}: ${v}`;
                    labelsDiv.appendChild(label);
                });
                card.appendChild(labelsDiv);
            }

            return card;
        }

        // update an existing card element in-place (only changed parts)
        function updateCardElement(card, status) {
            // update status class on card
            card.className = `card ${status.status}`;

            // update status badge
            const badge = card.querySelector('.status-badge');
            if (badge) {
                badge.className = `status-badge ${status.status}`;
                badge.textContent = status.status;
            }

            // update latency
            const latency = card.querySelector('.card-latency');
            if (latency) {
                latency.textContent = `${status.response_time_ms ?? 0}ms`;
            }

            // update time
            const time = card.querySelector('.card-time');
            if (time) {
                time.textContent = formatRelativeTime(status.checked_at);
            }

            // update stale badge
            updateStaleBadge(card, status);

            // handle error: add, update, or remove
            let error = card.querySelector('.card-error');
            if (status.error) {
                if (!error) {
                    error = document.createElement('div');
                    error.className = 'card-error';
                    // insert before labels if they exist, otherwise at end
                    const labels = card.querySelector('.card-labels');
                    if (labels) {
                        card.insertBefore(error, labels);
                    } else {
                        card.appendChild(error);
                    }
                }
                error.textContent = status.error;
            } else if (error) {
                error.remove();
            }
        }

        // insert a card in sorted position (alphabetical by name)
        function insertCardSorted(card, name) {
            const sortedNames = Array.from(statuses.keys()).sort((a, b) => a.localeCompare(b));
            const insertIndex = sortedNames.indexOf(name);

            if (insertIndex === sortedNames.length - 1 || grid.children.length === 0) {
                // append at end
                grid.appendChild(card);
            } else {
                // find the next card and insert before it
                const nextName = sortedNames[insertIndex + 1];
                const nextCard = cardElements.get(nextName);
                if (nextCard && nextCard.parentNode === grid) {
                    grid.insertBefore(card, nextCard);
                } else {
                    grid.appendChild(card);
                }
            }
        }

        // update or create a single card
        function updateCard(status) {
            // clear loading state on first card
            if (isShowingLoadingState) {
                grid.innerHTML = '';
                isShowingLoadingState = false;
            }

            const existingCard = cardElements.get(status.name);

            if (existingCard) {
                // update existing card in-place
                updateCardElement(existingCard, status);
            } else {
                // create new card and insert in sorted position
                const card = createCardElement(status);
                initCardHoverListeners(card);
                cardElements.set(status.name, card);
                insertCardSorted(card, status.name);
            }
        }

        // restore loading state (used when connection lost and statuses cleared)
        function showLoadingState() {
            if (!isShowingLoadingState) {
                grid.innerHTML = `
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <p>Waiting for first poll...</p>
                    </div>
                `;
                isShowingLoadingState = true;
                cardElements.clear();
            }
        }

        // update summary counts
        function updateSummary() {
            let up = 0, degraded = 0, down = 0;

            statuses.forEach(status => {
                if (status.status === 'up') up++;
                else if (status.status === 'degraded') degraded++;
                else down++;
            });

            upCount.textContent = up;
            degradedCount.textContent = degraded;
            downCount.textContent = down;
        }

        // update the global "last updated" display in the header
        function updateGlobalStaleness() {
            const lastUpdatedEl = document.getElementById('lastUpdated');
            const textEl = lastUpdatedEl?.querySelector('.last-updated-text');

            if (!lastUpdatedEl || !textEl) return;

            if (!lastUpdateTime) {
                textEl.textContent = 'Last updated: --';
                lastUpdatedEl.classList.remove('stale');
                lastUpdatedEl.removeAttribute('title');
                return;
            }

            const now = Date.now();
            const diffMs = now - lastUpdateTime;
            const isGlobalStale = diffMs > STALE_THRESHOLD_MS;

            // format the time
            const diffSec = Math.floor(diffMs / 1000);
            let timeText;
            if (diffSec < 5) {
                timeText = 'just now';
            } else if (diffSec < 60) {
                timeText = `${diffSec}s ago`;
            } else if (diffSec < 3600) {
                timeText = `${Math.floor(diffSec / 60)}m ago`;
            } else {
                timeText = `${Math.floor(diffSec / 3600)}h ago`;
            }

            textEl.textContent = `Last updated: ${timeText}`;

            if (isGlobalStale) {
                lastUpdatedEl.classList.add('stale');
                lastUpdatedEl.setAttribute('title', 'No updates received in over 2 minutes - connection may be stale');
            } else {
                lastUpdatedEl.classList.remove('stale');
                lastUpdatedEl.removeAttribute('title');
            }
        }

        // apply the current filter to all cards
        function applyFilter() {
            let visibleCount = 0;

            cardElements.forEach((card, name) => {
                const status = statuses.get(name);
                if (!status) return;

                const shouldShow = activeFilter === null || status.status === activeFilter;

                if (shouldShow) {
                    card.classList.remove('filtered-out');
                    visibleCount++;
                } else {
                    card.classList.add('filtered-out');
                }
            });

            updateEmptyState(visibleCount);
        }

        // show or hide the empty state message
        function updateEmptyState(visibleCount) {
            const existingEmpty = grid.querySelector('.empty-state');

            if (activeFilter !== null && visibleCount === 0 && !isShowingLoadingState) {
                if (!existingEmpty) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'empty-state';
                    emptyState.setAttribute('role', 'status');
                    emptyState.setAttribute('aria-live', 'polite');
                    emptyState.innerHTML = `
                        <div class="empty-state-icon" aria-hidden="true">&#x1F50D;</div>
                        <p class="empty-state-message">No endpoints with status "${activeFilter}"</p>
                        <p class="empty-state-hint">Click the filter again to show all endpoints</p>
                    `;
                    grid.appendChild(emptyState);
                }
            } else if (existingEmpty) {
                existingEmpty.remove();
            }
        }

        // toggle a filter on/off or switch to a different filter
        function toggleFilter(status) {
            const summaryItems = document.querySelectorAll('.summary-item');

            if (activeFilter === status) {
                // clicking same filter: clear it
                activeFilter = null;
                summaryItems.forEach(item => item.setAttribute('aria-pressed', 'false'));
            } else {
                // clicking different filter: switch to it
                activeFilter = status;
                summaryItems.forEach(item => {
                    const isActive = item.dataset.status === status;
                    item.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
            }

            applyFilter();
        }

        // set up filter event listeners on summary items
        function initFilterListeners() {
            const summaryItems = document.querySelectorAll('.summary-item');

            summaryItems.forEach(item => {
                const status = item.dataset.status;

                // click handler
                item.addEventListener('click', () => toggleFilter(status));

                // keyboard handler for Enter and Space
                item.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleFilter(status);
                    }
                });
            });
        }

        // handle a status update
        function handleStatusUpdate(status) {
            const existing = statuses.get(status.name);
            const statusChanged = existing && existing.status !== status.status;

            statuses.set(status.name, status);

            // track when we last received any update
            lastUpdateTime = Date.now();
            updateGlobalStaleness();

            updateCard(status);
            updateSummary();

            // pulse animation if status changed
            if (statusChanged) {
                const card = cardElements.get(status.name);
                if (card) {
                    card.classList.add('pulse');
                    setTimeout(() => card.classList.remove('pulse'), 500);
                }
            }

            // re-apply filter to handle status changes (cards appear/disappear as status changes)
            applyFilter();
        }

        // connect to SSE
        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/sse');

            eventSource.onopen = () => {
                connectionDot.classList.add('connected');
                connectionText.textContent = 'Connected';
                reconnectAttempts = 0;
            };

            eventSource.onmessage = (event) => {
                try {
                    const status = JSON.parse(event.data);
                    handleStatusUpdate(status);
                } catch (e) {
                    console.error('Failed to parse SSE message:', e);
                }
            };

            eventSource.onerror = () => {
                connectionDot.classList.remove('connected');
                connectionText.textContent = 'Reconnecting...';
                eventSource.close();

                // update staleness display immediately on disconnect
                // (note: we preserve lastUpdateTime to show how long since last successful update)
                updateGlobalStaleness();

                // exponential backoff reconnect
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                setTimeout(connectSSE, delay);
            };
        }

        // update relative times and staleness indicators periodically
        function updateRelativeTimes() {
            statuses.forEach((status, name) => {
                const card = cardElements.get(name);
                if (card) {
                    const time = card.querySelector('.card-time');
                    if (time) {
                        time.textContent = formatRelativeTime(status.checked_at);
                    }

                    // update per-card stale badge
                    updateStaleBadge(card, status);
                }
            });

            // update global staleness indicator
            updateGlobalStaleness();
        }

        // start
        initFilterListeners();
        connectSSE();
        setInterval(updateRelativeTimes, 5000);
    </script>
</body>
</html>
